---
show: step

version: 1.0
enable_checker: true
---

# 列表 - 构造
## 回忆
- 上次了解了列表的索引
- 可以用中括号加索引找到相应的元素
- 也可以用index找到元素的位置
- 还可以用count找到元素的匹配数量
- 列表中的元素可以进行什么样的计算么？🤔

### 回忆字符串

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630203640962)

- 字符串可以进行加法和乘法的运算
- 但是这个到底是什么样的过程呢
- 去一个网站观察
- Start visualizing

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630203709851)

### 选择

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630208623942)

- 点击Live Programming Mode
- 然后进入到试试编程模式

### 字符串运算

- 这种直接的计算
- 并不能为内存中的变量赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209077502)
- 在左边的frames的位置是空的
- 现在尝试赋值

### 赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209062770)

- 有两个变量在Stack栈空间有了Frames
- 可以用prev和next控制流程运行
- 数字型变量的情况呢？

### 数字变量

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209240049)

- 可以看到数字变量都在帧栈空间
- 那么列表list变量呢？

### 列表变量

- 可以看到l变量在帧栈上有一个位置
- 这里面存储着堆Heap上的地址
- 从这里指向Heap堆空间
- 堆空间里面存储着具体的列表元素
- 栈空间存储着堆空间的地址引用

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209428885)

- 注意那条带箭头的线
- 左边的变量在Frames中
- 引用者右边Heap空间中的内容

### 空列表

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209485488)

- 把空列表赋给l
- l仍然在栈空间
- l仍然指向堆空间
- l指向堆空间一个新的空列表
- 原来的列表没有被任何变量所指
- 会被垃圾回收

### None
![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209628126)

- 把None赋给l
- l仍然在栈空间
- l不指向堆空间
- 堆空间里面刚才的空列表没有被任何变量所指
- 会被垃圾回收
- 那我们来看看列表的赋值运算

### 分别赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210333943)

- l1、l2是两个不同的列表
- 虽然都指向list("oeasy")
- 但是在堆空间是两个不同的list
- 各是各的
- 那什么叫不是各是各的呢？

### 用列表赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210495419)

- l2 = l1 
- 让l2 指向 l1 所指向的堆空间的list对象
- 这样不论是l1还是l2
- append都会统一地在那个堆空间下添加列表项
- 如果我想要让l2 的内容和 l1 相等
- 但是分别指向不同的堆空间
- 应该如何呢？

### getrefcount
- 这个函数可以得到heap中空间到底由几个变量进行引用

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830125600)

- 明明是l1、l2两个变量啊
- 查看帮助

### 帮助手册

- 本来确实应该是两个
- 但是由于这个函数调用的时候
- 在函数内部还有一个参数变量也引用了这个位置
- 所以会比想象地变量多1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830139942)

### copy函数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210731635)

- 返回列表的浅拷贝
- 试试

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210778781)

- 拷贝明白了
- 分别的指向两个列表位置
- 浅是什么意思
- 还不清楚
- 再试试其他运算

### 加法运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210864598)

- 首先是可以加的
- 但是加的结果没有赋给任何变量
- 就在寄存器的风中
- 消失了

### 加法并赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210997707)

- 把加法的结果赋给l3
- l1、l2、l3三个变量指向不同的堆对象地址
- 可以把这个东西赋给l1么？

### 赋值细节
![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211221361)

- 加法运算是先复制l1里面的元素
- 然后追加l2里面的元素
- 可以把加法运算的结果赋给l1
- l1原来所指向的list列表就没有人引用了
- 空间会被系统回收
- 能否直接在l1之后进行追加

### 列表追加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631580147683)

- 这里使用切片a[3:]
- 其实就是在a的最后一个元素后面再追加列表b
- 然后a就是被扩展 extend了
- 这个时候其实有个新函数extend

### extend
![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211311655)

- extend是把参数里面的列表项循环地放到主体上
- 效率更高

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211378376)

- 而加法运算是新建一个列表
- 然后把l1的列表项都拿过来
- 再把l2的列表项都拿过来
- 最后把相加结果赋给l1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211451887)

- 那这个extend和append有什么区别呢？

### 区别

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631579842400)

- 操作对象不同
- append添加的是具体的元素
- extend是追加另一个列表
- 我们再试试乘法运算

### 乘法

- 乘法的本质就是累加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630222596114)

- 本质就是在heap区生成一个新的列表
- 然后把这个列表的实际地址
- 赋给一个在stack区的列表对象
### 空列表

- 如果本身就是空列表
- 列表里面没有列表项
- 乘多少还是空的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630241238365)

- 但如果这里面有东西
- 乘出来列表项就翻倍了
- 即使里面是空列表
- 空列表也翻倍

### 总结 
- 这次我们了解了列表的运算
- 赋值运算
	- 本质是把heap区中的列表对象地址付给对方
	- 可以用copy新建一个浅copy再赋给变量
- 加法
	- 加法的本质是在heap区中新建列表完成加法
	- =把加法的结果赋给变量
	- 也可以用extend在当前列表位置继续添加列表项
- 乘法
	- 乘法的本质是累加
	- 结果也是放在heap区
	- 可以被赋值给变量
- 加法乘法都是让列表变长
- 可以让列表变短吗？🤔
- 下次再说👋