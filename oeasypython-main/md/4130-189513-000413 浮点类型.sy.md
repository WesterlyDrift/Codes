---
show: step

version: 1.0
enable_checker: true
---

# 负数表示
## 回忆
- 上次观察余数细节
- 有三种取整方法
	- 向上天花板
	- 向下地板
	- 四舍五入
- 整除取余数用的都是向下地板法
- 无限小数到底是怎么使用的呢？🤪

### 小数细节

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446578924)

- 小数使用基本上是ok的
- 但是有的时候也会出现无法理解的情况

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446614955)

### 观察

- 观察数据类型

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446662095)

- 数据是float类型的
- 什么是float呢？
- help(float)


### 浮点类型float

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211029-1635515488500)

- float类里面有个成员函数hex

### 二进制形态

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446954069)

- p的意思是小数点point
- p前面的是有效数字
	- 可以有正负号
	- 0x说明是16进制的表示法
- p后面是小数点浮动位置
	- -4就是左移4位
	- +1就是右移1位
- 因为小数点point可以浮动float
	- 所以这种类型叫做浮点数floating-point number

### 特别注意

- float是一个类的名字
- 最好不要用他作为变量名
- 因为
	- 一旦float作为一个变量理解
	- 就不能使用float函数把字符串转化为浮点型了

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630200328957)

- 这个原理和str、int等类一样
	- 而且浮点型变量的精度要低于整型变量
	- 这听起来很难以置信
	- 我们来看看

### 精度问题

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211003-1633222609130)

- 真的是这样(浮点型数字的有效数字位数低于整型数字)
- 浮点型数字被截断了
	- 丢失了一位精度
	- 而且最后一位9还给舍了
- 这是真的么？
- 这是为什么？

### 验证

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447597089)

- 1.0 对应 `\x3f\x80\x00\x00`
- 这个规则叫做ieee754 32-bit浮点数
- 存储在四个字节
- ">f"为什么可以把二进制形态改变？
- 这涉及到一个东西叫做
	- 字节序

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211029-1635516032723)

### 字节序对比

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635559712503)

### little-endian 

- <f用的是小字节序
	- 编码模式属于small-endian
	- 最低有效位（least significant byte）放在低地址a

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635559260042)

- 这是目前CISC指令集架构(x86、x86-64)用的字节序
- 另一种字节序是大字节序

### big-endian
- >f是按下图中的字节排序
	- 编码模式属于big-endian
	- 最高有效位（most significant byte）落在低地址

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635559602632)

- 这是目前RISC指令集架构(RISC、MIPS)用的字节序
- 这也是我们看起来比较顺的字节序
- 如下图所示

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447655167)

- http://www.binaryconvert.com/result_float.html?hexadecimal=3F800000

### 继续验证

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447889894)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447904479)

- 2.0 和 1.0 相比
	- 指数部分+1
	- 尾数部分没有变化

### 4.0

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448007718)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448017365)

- 4.0 和 2.0 相比
	- 原基础上又乘以 2
	- 相当于指数 +1 
	- 尾数没有变化
- 如果是0.5呢？

### 0.5

- 0.5是在1.0的基础上除以 2
- 相当于在1.0的指数部分减一

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448346168)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448317994)

- 指数部分从1.0的`\x3f\x80`到 0.5的 `\x3f\x00`

### 尾数部分

- 尾数怎么用呢？
- 回到1.0
- 然后观察1.5

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448678597)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448693253)

- 1.5 和 1.0 相比
	- 指数没有变化
	- 尾数把第一位改成了1
- (1.1)<sub>2</sub> 等于 (1.5)<sub>10</sub>

### 3.0
- 3.0 和 1.5 相比
	- 尾数没有变化
	- 指数+1
	- 相当于乘以2

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448861896)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448872411)

### 负数呢？
- -3.0 和 3.0 相比
	- 指数和尾数都没有变化
	- 符号位从0变1
	- 意味着这是负数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448971211)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448962448)

### 浮点数总结

- 浮点数有三个部分组成
	- 符号位 
		- 负责正负
		- 0 就是正
		- 1 就是负
	- 指数部分 
		- 负责翻倍
		- 以01111111为平衡位置
		- +1 相当于乘以 2
		- -1 相当于除以 2
	- 尾数部分
		- 前面有一个1不显示
		- 默认就是1.0
		- 第一位写一个1 代表 1.1
		- 第二位再写一个1 代表 1.11
- 那我们回来再看看0.1

### 0.1

- 最初的问题是3个0.1相加等于0.30000000000000004
- 观察0.1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449640633)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449649321)

- 这个算出来 
- 比0.1还小呢
- 不可能超过0.3🤪

### 双精度
- 我们前面介绍的都是单精度浮点型float
	- 单精度浮点型float总共4位
- 还有一种双精度浮点型double
	- 总共8位

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449849303)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629449826665)

- 那为什么加起来是0.30000000000000004呢？
- 我们先来看看和的双精度数的二进制形态

### 和的形态

- 0.1+0.1+0.1的双精度形态
- `\x34\x33\x33\x33\x33\x33\xd3\x3f`

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629452878843)

- `\x34\x33\x33\x33\x33\x33\xd3\x3f` 对应十进制
- 0.30000000000000004
- 前后都能说通
- 可是，这个和0.1到底是怎么加的呢？

### 计算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629454276318)

- 首先获得0.1的双精度浮点型的二进制形态
- 抛去符号位和指数部分
- 还剩下总共52位2进制数，如上图选中的数字部分
- 1001100110011001100110011001100110011001100110011010
- 把这个数字复制下来

### 补位

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635563873405)

- 有效数字前面有个缺省的1
	- 把这52位2进制数前面补1
	- 11001100110011001100110011001100110011001100110011010
	- 然后乘以3、除以4，相当于向右移动两位
	- 为的是形成1.XXXX的有效数字形态
	- 结果向上取整
- 然后转化为16进制
	- 0x3333333333334
	- 依然是52位2进制数
	- 共13位16进制数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635564179195)

- 与0.1+0.1+0.1得到的0.30000000000000004
- 对比直接进行的二进制编码

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635564281409)

- 这是一致的
- 我可以手算这个过程么？
- 说干就干，走起来~

### 手算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629454276318)

- 把后52位复制出来


### 计算过程
![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211003-1633223204797)

- 第一步是相加
- 两个一样的数，左移1位
- 然后再加上自身
- 得到结果是尾数
- 尾数以1.xxx开头
- 向右移动2位
- 然后掐头去掉开头默认的1
- 结尾多出的两位有进位
- 保持52位


### 浮点运算进化
- 早年间其实Guido的python是这样的
	- 整型变量可以和整型变量运算
	- 浮点型变量可以和浮点型变量运算
	- 整型和浮点型之间不能加减乘除
	- 为什么呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630842627155)


### 原因
- 指令集不同
	- 整型数字加法有自己的指令集
	- 浮点型数字加法有自己的指令集
	- 没有一个指令能算整型加上浮点型
	- 要在系统里把整型转化为浮点型
	- 再用浮点型指令集来做
- 早年间甚至有专门负责浮点运算的协处理器
- 想象一下 1e100 + 1e-100 
	- 有效数字需要对齐

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630842827722)

### 解决

- 这个东西虽然有了指令
- 但是还是比较复杂的
- 解决这个问题的是Tim Peters，美国的一位软件工程师
- 他在Python发展的早期，就参与了这个语言的开发和设计。

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630808360683)


- 他原来在为大型主机写编译器
- 后来业余时间加入了python这个项目
- 他是Python语言以及CPython的主要contributor之一
- 他创造了Timsort hybrid sorting算法
- 这个算法从Python2.3开始就在使用
- 很硬核
- 原来的整型和浮点型不能相加减
- 他让两个不同类型的数字可以相加
- Python标准模块中的doctest和timeit，也是他的大作
- 他也是python之禅的作者


### python之禅学

- 2001年秋，Foretec（一家会议组织公司）正在准备召开第十届International Python Conference（IPC 10，Pycon的前身）
- Foretec打算征集一条印在会议T恤衫上的标语，最终他们从Python社区收到了500多条投稿
- Foretec邀请了Python的核心开发Guido，Fred，Jeremy，Tim Peters，Barry 等来担任评审
- 评审委员们从投稿中过滤出了130多条后就一直没有进展，直到会议快要召开时他们也没有确定最终标语
- 在会议就要开始的前几天，到了评审们不得不做出决定的时候了
- 于是由Tim Peters和Barry两人轮流评审，每人每次淘汰一半留下一半，直到最后只剩一条
- 最终，“import this”被选了出来，大家对“import this”非常满意
- 但是当选择了这条以后，他们意识到他们必须要实现它
- 经过简单的讨论后，“import this”的被定为输出Tim Peters写的《The Zen of Python》
- ——Python编程和设计的指导原则。
- this.py在lib里面是标准库
- 去找一下

### 查找

- sudo find / -name "this.py"

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630809456883)

- 这是啥？

### 解码

- 代码中的s字符串使用了rot13加密
- rot13就是凯撒密码的一种，每个字母变换为它后面的第13个字母

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630809549374)

- 等到IPC 10结束后
- 他们悄悄的把代码提交到Python 2.2.1
- 过了一段时间，才逐渐有人发现“import this”这个彩蛋

### 总结 

- 这次了解浮点类型变量
- 有两种表示法
	- float 4字节 单精度浮点型
	- double 8字节 双精度浮点型
- 浮点型特点
	- 第一位都是符号位
	- 小数点都浮动
	- 浮动程度由指数部分决定
	- 尾数部分默认1开头
	- 后面的小数部分是有效数字
- 这就是浮点类型的数据
- 不过很容易出错
- 有没有减少出错的方法？🤪
- 下次再说👋